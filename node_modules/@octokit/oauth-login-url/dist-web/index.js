function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

const BASE_URL = 'https://github.com/login/oauth/authorize';
function oauthLoginUrl(options) {
  const scopesNormalized = typeof options.scopes === 'string' ? options.scopes.split(/[,\s]+/).filter(Boolean) : Array.isArray(options.scopes) ? options.scopes : [];
  const result = {
    allowSignup: options.allowSignup === false ? false : true,
    clientId: options.clientId,
    login: options.login || null,
    redirectUrl: options.redirectUrl || null,
    scopes: scopesNormalized,
    state: options.state || Math.random().toString(36).substr(2),
    url: ''
  };
  result.url = urlBuilderAuthorize(BASE_URL, result);
  return result;
}

function urlBuilderAuthorize(base, options) {
  const map = {
    allowSignup: 'allow_signup',
    clientId: 'client_id',
    login: 'login',
    redirectUrl: 'redirect_url',
    scopes: 'scope',
    state: 'state'
  };
  let url = base;
  Object.entries(options).filter((_ref) => {
    let _ref2 = _slicedToArray(_ref, 2),
        k = _ref2[0],
        v = _ref2[1];

    return v !== null && k !== 'url';
  }) // Filter out keys that are null and remove the url key
  .filter((_ref3) => {
    let _ref4 = _slicedToArray(_ref3, 2),
        v = _ref4[1];

    return Array.isArray(v) ? v.length !== 0 : true;
  }) // Filter out empty Array
  .map((_ref5) => {
    let _ref6 = _slicedToArray(_ref5, 1),
        key = _ref6[0];

    return [map[key], "".concat(options[key])];
  }) // Map Array with the proper URL parameter names and change the value to a string using template strings
  .forEach((_ref7, index) => {
    let _ref8 = _slicedToArray(_ref7, 2),
        key = _ref8[0],
        value = _ref8[1];

    url += index === 0 ? "?" : '&';
    url += "".concat(key, "=").concat(value);
  });
  return url;
}

export { BASE_URL, oauthLoginUrl };
